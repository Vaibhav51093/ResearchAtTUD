# Boilerplate code generated by OVITO Pro 3.7.4
from ovito.io import *
from ovito.modifiers import *
from ovito.data import *
from ovito.pipeline import *
import numpy as np

#########################################
### Start of User Input #################
#########################################

# input and output file
infile = '/home/marcel/tmp/sun_GB/Nasicon_diagonal_1x2x1.data'
outfile = "/home/marcel/tmp/sun_GB/test_GB.data"

# GB type (only works for twist boundaries with [0 0 1] rotation axis and hexagonal symmetry!)
# To get the values, use pymatgen or any other means. For complicated rhombohedral systems,
# I recommend to use a >>>hexagonal<<< dummy cell containing >>>only one atom<<<  with the same
# cell parameters as the one we are interested in
sigma = 7
full_twist_angle = 21.786789298261812

# Vaccum and grain thickness
vacuum_thickness  = 3   # in Angstrom, added on both sides
grain_thickness_z = 2   # number of replicas perpendicular to the GB

# Adjust model size (so to say the area of the model)
final_replicate_x = 1   # will be applied at last to adjust system size
final_replicate_y = 1   # will be applied at last to adjust system size

# Shifts for adjusting termination and a-b shift.
# I recommend using fractional values of the cell (between 0.0 and 1.0)
# But take care and think about which cell you use as input!
shifts_in_fractional = True             # True: fractional shifts (along cell vectors),
                                        # False: Shift in angstrom [cartesian (!)]

z_shift_lower_grain_termination =  0.2   # positive/negative values shift atoms up/down along z direction
z_shift_upper_grain_termination = -0.2   # positive/negative values shift atoms up/down along z direction

ab_shift         = [0.0, 0.0]            # lower grain remains untouched, upper grain will be shifted


### The following settings will most likely not need any changes:

# An intermediate replication is performed to guarantee that there are enough atoms.
# If you go to very high sigma values, then you might need to increase the values here
intermediate_replication_x = 15
intermediate_replication_y = 9

# Cutoff distance to delete overlapping particles (from final wrapping)
overlap_distance = 0.05

#########################################
### End of User Input ####################
#########################################





# Data import:
pipeline = import_file(infile)

# Get length of first axis and y component of second axis. Needed for several things later
data = pipeline.compute()
x_length = data.cell[0, 0]
z_length = data.cell[2, 2]

# Create the property low_up_as_0_1 to make selection of the different grains easy
# In this way, the first loaded data is directly marked as '1' and  will be the upper grain
def create_low_up_selection(frame: int, data: DataCollection):
    data.particles_.create_property("low_up_as_0_1", data=np.ones(data.particles.count))
pipeline.modifiers.append(create_low_up_selection)

# Load the same structure again (via Combine datasets). This will be the lower grain:
mod_load_second_grain = CombineDatasetsModifier()
pipeline.modifiers.append(mod_load_second_grain)
mod_load_second_grain.source.load(infile)

# Depending on user input, convert shifts into Angstrom
ab_shift = np.array(ab_shift)
if shifts_in_fractional == True:
    z_shift_lower = z_shift_lower_grain_termination * z_length
    z_shift_upper = z_shift_upper_grain_termination * z_length
    x_shift = ab_shift[0] * data.cell[0, 0] + ab_shift[1] * data.cell[1, 0] # along first axis!
    y_shift = ab_shift[0] * data.cell[0, 1] + ab_shift[1] * data.cell[1, 1] # along second axis!
elif shifts_in_fractional == False:
    z_shift_lower = z_shift_lower_grain_termination
    z_shift_upper = z_shift_upper_grain_termination
    x_shift_upper = ab_shift[0] # pure cartesian shift!
    y_shift_upper = ab_shift[1] # pure cartesian shift!

# Select lower grain and shift along z to adjust the termination:
pipeline.modifiers.append(ExpressionSelectionModifier(expression = 'low_up_as_0_1 == 0'))
pipeline.modifiers.append(AffineTransformationModifier(
    transformation = [[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, z_shift_lower]],
    only_selected = True, 
    operate_on = {'particles'}))

# Select upper grain and shift along z to adjust the termination:
pipeline.modifiers.append(ExpressionSelectionModifier(expression = 'low_up_as_0_1 == 1'))
pipeline.modifiers.append(AffineTransformationModifier(
    transformation = [[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, z_shift_upper]],
    only_selected = True, 
    operate_on = {'particles'}))

# Wrap at periodic boundaries to get those shifted atoms back into the box:
pipeline.modifiers.append(WrapPeriodicImagesModifier())

# Replicate to adjust grain thickness and to ensure to have enough atoms along x and y:
pipeline.modifiers.append(ReplicateModifier(
    num_x = intermediate_replication_x,
    num_y = intermediate_replication_y,
    num_z = grain_thickness_z))

# Select lower grain. Rotate atoms (not cell) and shift upwards by half vaccum:
pipeline.modifiers.append(ExpressionSelectionModifier(expression = 'low_up_as_0_1 == 0'))
pipeline.modifiers.append(AffineTransformationModifier(
    transformation = [[ np.cos(full_twist_angle/2/180*np.pi), np.sin(full_twist_angle/2/180*np.pi), 0.0, 0.0],
                      [-np.sin(full_twist_angle/2/180*np.pi), np.cos(full_twist_angle/2/180*np.pi), 0.0, 0.0],
                      [0.0, 0.0, 1.0, 0.5*vacuum_thickness]],
    only_selected = True,
    operate_on = {'particles'}))

# Select upper grain. Rotate atoms (not cell) and shift upwards and apply a-b-shift
pipeline.modifiers.append(ExpressionSelectionModifier(expression = 'low_up_as_0_1 == 1'))
pipeline.modifiers.append(AffineTransformationModifier(
    transformation = [[ np.cos(full_twist_angle/2/180*np.pi), -np.sin(full_twist_angle/2/180*np.pi), 0.0, x_shift],
                      [ np.sin(full_twist_angle/2/180*np.pi),  np.cos(full_twist_angle/2/180*np.pi), 0.0, y_shift],
                      [0.0, 0.0, 1.0, 1.5*vacuum_thickness+grain_thickness_z*z_length]],
    only_selected = True,
    operate_on = {'particles'}))

# OuterBox:
pipeline.modifiers.append(AffineTransformationModifier(
    target_cell = [[np.sin(60/180*np.pi)*x_length*2*np.sqrt(7), 0.0, 0.0, 0.0],
                   [0.0, x_length*np.sqrt(sigma), 0.0, 0.0],
                   [0.0, 0.0, 2*vacuum_thickness+2*grain_thickness_z*z_length, 0.0]],
    relative_mode = False, 
    operate_on = {'cell'}))

# Wrap at periodic boundaries and clear Selection:
pipeline.modifiers.append(WrapPeriodicImagesModifier())
pipeline.modifiers.append(ClearSelectionModifier())

# Select all duplicate atoms
def select_duplicates(frame, data):

    # Access the "Selection"
    selection = data.particles_.create_property('Selection')

    # Prepare neighbor finder
    finder = CutoffNeighborFinder(overlap_distance, data)

    # Iterate over all particles
    for index in range(data.particles.count):

        # Iterate over all nearby particles around the current center particle
        for neigh in finder.find(index):

            # Once we find a neighbor which hasn't been marked yet,
            # mark the current center particle. This test is to ensure that we
            # always select only one of the particles in a close pair.
            if selection[neigh.index] == 0:
                selection[index] = 1
                break
pipeline.modifiers.append(select_duplicates)

# Delete the selected duplicates:
pipeline.modifiers.append(DeleteSelectedModifier())

# Replicate parallel to the grain boundary
pipeline.modifiers.append(ReplicateModifier(
    num_x = final_replicate_x,
    num_y = final_replicate_y))

# Output structure
export_file(pipeline, outfile, "lammps/data")



